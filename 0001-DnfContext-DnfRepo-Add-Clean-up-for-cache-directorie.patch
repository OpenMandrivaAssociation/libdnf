From 958ef096202e1efc3aed8698dde51252ab4cd092 Mon Sep 17 00:00:00 2001
From: Ruixin <peter.bao@mail.utoronto.ca>
Date: Mon, 18 Sep 2017 19:55:09 +0000
Subject: [PATCH 1/4] DnfContext/DnfRepo: Add Clean up for cache directories
 with new names

A new naming convention for cache directories are introduced for
solving https://github.com/rpm-software-management/libdnf/issues/148.

Now, the cache directory name will end with releasever_basearch(e.g 25_x86_64)
to allow users distinguish cache directories from different versions of
operating system

Method for cache cleaning up was also introduced for solving the above issue.

Now, the added function will allow users to perform similar operations
as 'yum clean' with options including expire-cache, metadata, packages,
and all. However, this function is not integrated for libdnf CLI usage yet,
it is mainly targeted to function as an API for other repos' usage.

Few tests are added for future regression.

Closes: #315
Approved by: cgwalters
---
 data/tests/cache-test/yum.repos.d/fedora.repo |   4 +
 libdnf/dnf-context.c                          |  96 +++++++++++++++++++++
 libdnf/dnf-context.h                          |  19 +++++
 libdnf/dnf-repo.c                             |   8 +-
 libdnf/dnf-utils.c                            | 104 +++++++++++++++++++++--
 libdnf/dnf-utils.h                            |   5 ++
 tests/libdnf/dnf-self-test.c                  | 116 +++++++++++++++++++++++++-
 7 files changed, 344 insertions(+), 8 deletions(-)
 create mode 100644 data/tests/cache-test/yum.repos.d/fedora.repo

diff --git a/data/tests/cache-test/yum.repos.d/fedora.repo b/data/tests/cache-test/yum.repos.d/fedora.repo
new file mode 100644
index 0000000..6537d98
--- /dev/null
+++ b/data/tests/cache-test/yum.repos.d/fedora.repo
@@ -0,0 +1,4 @@
+[fedora]
+name=Fedora $releasever - $basearch
+enabled=1
+skip_if_unavailable=False
diff --git a/libdnf/dnf-context.c b/libdnf/dnf-context.c
index ccc45ad..47d6533 100644
--- a/libdnf/dnf-context.c
+++ b/libdnf/dnf-context.c
@@ -2009,6 +2009,102 @@ dnf_context_invalidate(DnfContext *context, const gchar *message)
 }
 
 /**
+ * dnf_context_clean_cache:
+ * @context: a #DnfContext instance.
+ * @flags: #DnfContextCleanFlags flag, e.g. %DNF_CONTEXT_CLEAN_EXPIRE_CACHE
+ * @error: a #GError instance
+ *
+ * Clean the cache content in the current cache directory based
+ * on the context flags. A valid cache directory and lock directory
+ * is expected to be set prior to using this function. Use it with care.
+ *
+ * Currently support four different clean flags:
+ * 1: DNF_CONTEXT_CLEAN_EXPIRE_CACHE: Elminate the entries that give information about cache entries' age. i.e: 'repomd.xml' will be deleted in libdnf case
+ * 2: DNF_CONTEXT_CLEAN_PACKAGES: Eliminate any cached packages. i.e: 'packages' folder will be deleted
+ * 3: DNF_CONTEXT_CLEAN_METADATA: Eliminate all of the files which libdnf uses to determine remote availability of packages. i.e: 'repodata'folder and 'metalink.xml' will be deleted
+ * 4: DNF_CONTEXT_CLEAN_ALL: Does all the actions above and clean up other files that are generated due to various reasons. e.g: cache directories from previous version of operating system
+ *
+ * Note: when DNF_CONTEXT_CLEAN_ALL flag is seen, the other flags will be ignored
+ *
+ * Returns: %TRUE for success, %FALSE otherwise
+ *
+ * Since: 0.9.4
+ **/
+gboolean
+dnf_context_clean_cache(DnfContext *context,
+                        DnfContextCleanFlags flags,
+                        GError **error)
+{
+    DnfRepo *src;
+    g_autoptr(GPtrArray) suffix_list = g_ptr_array_new();
+    const gchar* directory_location;
+    gboolean ret;
+    guint lock_id = 0;
+
+    /* Set up the context if it hasn't been set earlier */
+    if (!dnf_context_setup(context, NULL, error))
+        return FALSE;
+
+    DnfContextPrivate *priv = GET_PRIVATE(context);
+    /* We expect cache directories to be set when cleaning cache entries */
+    if (priv->cache_dir == NULL) {
+        g_set_error_literal(error,
+                            DNF_ERROR,
+                            DNF_ERROR_INTERNAL_ERROR,
+                            "No cache dir set");
+        return FALSE;
+    }
+
+    /* When clean all flags show up, we remove everything from cache directory */
+    if (flags & DNF_CONTEXT_CLEAN_ALL) {
+        return dnf_remove_recursive(priv->cache_dir, error);
+    }
+
+    /* We acquire the metadata related lock */
+    lock_id = dnf_lock_take(priv->lock,
+                            DNF_LOCK_TYPE_METADATA,
+                            DNF_LOCK_MODE_PROCESS,
+                            error);
+    if (lock_id == 0)
+        return FALSE;
+
+    /* After the above setup is done, we prepare file extensions based on flag types */
+    if (flags & DNF_CONTEXT_CLEAN_PACKAGES)
+        g_ptr_array_add(suffix_list, (char*) "packages");
+    if (flags & DNF_CONTEXT_CLEAN_METADATA) {
+        g_ptr_array_add(suffix_list, (char*) "metalink.xml");
+        g_ptr_array_add(suffix_list, (char*) "repodata");
+    }
+    if (flags & DNF_CONTEXT_CLEAN_EXPIRE_CACHE)
+        g_ptr_array_add(suffix_list, (char*) "repomd.xml");
+
+    /* Add a NULL terminator for future looping */
+    g_ptr_array_add(suffix_list, NULL);
+
+    /* We then start looping all of the repos to perform file deletion */
+    for (guint counter = 0; counter < priv->repos->len; counter++) {
+        src = g_ptr_array_index(priv->repos, counter);
+        gboolean deleteable_repo = dnf_repo_get_kind(src) == DNF_REPO_KIND_REMOTE;
+        directory_location = dnf_repo_get_location(src);
+
+        /* We check if the repo is qualified to be cleaned */
+        if (deleteable_repo &&
+            g_file_test(directory_location, G_FILE_TEST_EXISTS)) {
+            ret = dnf_delete_files_matching(directory_location,
+                                            (const char* const*) suffix_list->pdata,
+                                            error);
+            if(!ret)
+                goto out;
+            }
+        }
+
+    out:
+        /* release the acquired lock */
+        if (!dnf_lock_release(priv->lock, lock_id, error))
+            return FALSE;
+        return ret;
+}
+/**
  * dnf_context_new:
  *
  * Creates a new #DnfContext.
diff --git a/libdnf/dnf-context.h b/libdnf/dnf-context.h
index e03281f..06d5591 100644
--- a/libdnf/dnf-context.h
+++ b/libdnf/dnf-context.h
@@ -51,6 +51,22 @@ struct _DnfContextClass
 };
 
 /**
+ * DnfContextCleanFlags:
+ * @DNF_CONTEXT_CLEAN_EXPIRE_CACHE:            Clean the indicator file for cache directories' age
+ * @DNF_CONTEXT_CLEAN_PACKAGES:                Clean the packages section for cache
+ * @DNF_CONTEXT_CLEAN_METADATA:                Clean the metadata section for cache directories
+ * @DNF_CONTEXT_CLEAN_ALL:                     Clean out all of the cache directories
+ *
+ * The clean flags for cache directories cleaning.
+ **/
+typedef enum {
+        DNF_CONTEXT_CLEAN_EXPIRE_CACHE          = (1 << 0),
+        DNF_CONTEXT_CLEAN_PACKAGES              = (1 << 1),
+        DNF_CONTEXT_CLEAN_METADATA              = (1 << 2),
+        DNF_CONTEXT_CLEAN_ALL                   = (1 << 3),
+} DnfContextCleanFlags;
+
+/**
  * DnfContextInvalidateFlags:
  * @DNF_CONTEXT_INVALIDATE_FLAG_NONE:           No caches are invalid
  * @DNF_CONTEXT_INVALIDATE_FLAG_RPMDB:          The rpmdb cache is invalid
@@ -161,6 +177,9 @@ void             dnf_context_invalidate                 (DnfContext     *context
 void             dnf_context_invalidate_full            (DnfContext     *context,
                                                          const gchar    *message,
                                                          DnfContextInvalidateFlags flags);
+gboolean         dnf_context_clean_cache                (DnfContext     *context,
+                                                         DnfContextCleanFlags      flags,
+                                                         GError         **error);
 gboolean         dnf_context_install                    (DnfContext     *context,
                                                          const gchar    *name,
                                                          GError         **error);
diff --git a/libdnf/dnf-repo.c b/libdnf/dnf-repo.c
index 0159698..ea253e9 100644
--- a/libdnf/dnf-repo.c
+++ b/libdnf/dnf-repo.c
@@ -982,10 +982,16 @@ dnf_repo_set_keyfile_data(DnfRepo *repo, GError **error)
     /* set location if currently unset */
     if (!lr_handle_setopt(priv->repo_handle, error, LRO_LOCAL, 0L))
         return FALSE;
+
     if (priv->location == NULL) {
         g_autofree gchar *tmp = NULL;
+        /* make each repo's cache directory name has releasever and basearch as its suffix */
+        g_autofree gchar *file_name  = g_strjoin("-", priv->id,
+                                                 dnf_context_get_release_ver(priv->context),
+                                                 dnf_context_get_base_arch(priv->context), NULL);
+
         tmp = g_build_filename(dnf_context_get_cache_dir(priv->context),
-                               priv->id, NULL);
+                               file_name, NULL);
         dnf_repo_set_location(repo, tmp);
     }
 
diff --git a/libdnf/dnf-utils.c b/libdnf/dnf-utils.c
index 225c299..ff87627 100644
--- a/libdnf/dnf-utils.c
+++ b/libdnf/dnf-utils.c
@@ -119,13 +119,8 @@ dnf_remove_recursive(const gchar *directory, GError **error)
                 return FALSE;
         } else {
             g_debug("deleting file %s", src);
-            if ((g_unlink(src) != 0) && errno != ENOENT) {
-                g_set_error(error,
-                            DNF_ERROR,
-                            DNF_ERROR_INTERNAL_ERROR,
-                            "failed to unlink %s", src);
+            if (!dnf_ensure_file_unlinked(src, error))
                 return FALSE;
-            }
         }
     }
 
@@ -141,6 +136,103 @@ dnf_remove_recursive(const gchar *directory, GError **error)
     return TRUE;
 }
 
+
+/**
+ * dnf_ensure_file_unlinked:
+ * @src_path: the path to the file
+ * @error: A #GError, or %NULL
+ *
+ * Remove a file based on the file path,
+ * refactored from dnf_remove_recursive() function
+ *
+ * Returns: %FALSE if an error was set
+ *
+ * Since 0.9.4
+ **/
+gboolean
+dnf_ensure_file_unlinked(const gchar *src_path, GError **error)
+{
+    if ((unlink(src_path) != 0) && errno != ENOENT) {
+        g_set_error(error,
+                    DNF_ERROR,
+                    DNF_ERROR_INTERNAL_ERROR,
+                    "failed to unlink %s", src_path);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+/**
+ * dnf_delete_files_matching:
+ * @directory_path: the top level directory path to look at
+ * @patterns: the patterns that we are expecting from file/directory's name
+ * @error: a #GError instance, to track error
+ *
+ * Remove recursively all the files/directories that have names
+ * which match the patterns. Use with care
+ *
+ * There are several assumptions that are made in this function:
+ *
+ * 1: We assume the top level path( the path passed in initially)
+ * does not satisfy the criteria of matching the pattern
+ *
+ * 2: We assume the top level path itself is a directory initially
+ *
+ * Returns: %FALSE if failed to delete a file/directory
+ *
+ * Since: 0.9.4
+ **/
+gboolean
+dnf_delete_files_matching(const gchar* directory_path,
+                          const char* const* patterns,
+                          GError **error)
+{
+    const gchar *filename;
+    g_autoptr(GDir) dir = NULL;
+
+    /* try to open the direcotry*/
+    dir = g_dir_open(directory_path, 0, error);
+    if (dir == NULL) {
+        g_prefix_error(error, "Cannot open directory %s: ", directory_path);
+        return FALSE;
+    }
+    /* In the directory, we read each file and check if their name matches one of the patterns */
+    while ((filename = g_dir_read_name(dir))) {
+        g_autofree gchar *src = g_build_filename(directory_path, filename, NULL);
+        if (g_file_test(src, G_FILE_TEST_IS_DIR)) {
+            gboolean matching = FALSE;
+            for (char **iter = (char **) patterns; iter && *iter; iter++) {
+                const char* pattern = *iter;
+                if (g_str_has_suffix(filename, pattern)) {
+                    if (!dnf_remove_recursive(src, error))
+                        return FALSE;
+                    matching = TRUE;
+                    break;
+                }
+            }
+            if (!matching) {
+                /* If the directory does not match pattern, keep looking into it */
+                if (!dnf_delete_files_matching(src, patterns, error))
+                   return FALSE;
+            }
+        }
+        else {
+            /* This is for files in the directory, if matches, we directly delete it */
+            for (char **iter = (char **)patterns; iter && *iter; iter++) {
+                const char* pattern = *iter;
+                if (g_str_has_suffix(filename, pattern)) {
+                    if (!dnf_ensure_file_unlinked(src, error))
+                        return FALSE;
+                    break;
+                }
+            }
+        }
+    }
+
+    return TRUE;
+}
+
 /**
  * dnf_get_file_contents_allow_noent:
  * @path: File to open
diff --git a/libdnf/dnf-utils.h b/libdnf/dnf-utils.h
index d68e557..1df5521 100644
--- a/libdnf/dnf-utils.h
+++ b/libdnf/dnf-utils.h
@@ -27,6 +27,11 @@
 gchar           *dnf_realpath                       (const gchar            *path);
 gboolean         dnf_remove_recursive               (const gchar            *directory,
                                                      GError                 **error);
+gboolean         dnf_ensure_file_unlinked           (const gchar            *src_path,
+                                                     GError                 **error);
+gboolean         dnf_delete_files_matching          (const gchar            *directory_path,
+                                                     const char* const      *patterns,
+                                                     GError                 **error);
 gboolean         dnf_get_file_contents_allow_noent  (const gchar            *path,
                                                      gchar                  **out_contents,
                                                      gsize                  *length,
diff --git a/tests/libdnf/dnf-self-test.c b/tests/libdnf/dnf-self-test.c
index d3b4301..00ba311 100644
--- a/tests/libdnf/dnf-self-test.c
+++ b/tests/libdnf/dnf-self-test.c
@@ -22,7 +22,7 @@
 
 #include <glib-object.h>
 #include <stdlib.h>
-
+#include <glib/gstdio.h>
 #include "libdnf/libdnf.h"
 
 /**
@@ -1066,6 +1066,118 @@ dnf_repo_loader_gpg_asc_func(void)
     g_assert(ret);
 }
 
+static void
+dnf_repo_loader_cache_dir_check_func(void)
+{
+    DnfRepoLoader *repo_loader;
+    DnfRepo *repo;
+    gboolean ret;
+    g_autoptr(GError) error = NULL;
+    g_autoptr(DnfContext) ctx = NULL;
+    g_autofree gchar *repos_dir = NULL;
+    g_autofree gchar *cache_dir = NULL;
+    const char *cache_location = NULL;
+    g_autofree gchar *expected_cache_suffix = NULL;
+
+    /* set up local context*/
+    ctx = dnf_context_new();
+    repos_dir = dnf_test_get_filename("cache-test/yum.repos.d");
+    cache_dir = g_build_filename(TESTDATADIR, "cache-test/cache-dir", NULL);
+    dnf_context_set_repo_dir(ctx, repos_dir);
+    dnf_context_set_solv_dir(ctx, "/tmp");
+    dnf_context_set_cache_dir(ctx, cache_dir);
+
+    ret = dnf_context_setup(ctx, NULL, &error);
+    g_assert_no_error(error);
+    g_assert(ret);
+
+    /* get the testing repo */
+    repo_loader = dnf_repo_loader_new(ctx);
+    repo = dnf_repo_loader_get_repo_by_id(repo_loader, "fedora", &error);
+    g_assert_no_error(error);
+    g_assert(repo != NULL);
+
+    /* check the repo location to verify it has the correct suffix */
+    cache_location = dnf_repo_get_location(repo);
+    expected_cache_suffix =  g_strjoin("-", dnf_context_get_release_ver(ctx),
+                                       dnf_context_get_base_arch(ctx), NULL);
+    g_assert(g_str_has_suffix(cache_location, expected_cache_suffix));
+}
+
+
+static void
+dnf_context_cache_clean_check_func(void)
+{
+
+    DnfRepoLoader *repo_loader;
+    DnfRepo *repo;
+    gboolean ret;
+    g_autoptr(GError) error = NULL;
+    g_autoptr(DnfContext) ctx = NULL;
+    g_autofree gchar *repos_dir = NULL;
+    g_autofree gchar *cache_dir = NULL;
+    const gchar* repo_location;
+    guint file_result;
+
+    /* set up local context*/
+    ctx = dnf_context_new();
+    repos_dir = dnf_test_get_filename("cache-test/yum.repos.d");
+    cache_dir = g_build_filename(TESTDATADIR, "cache-test/cache-dir", NULL);
+    dnf_context_set_repo_dir(ctx, repos_dir);
+    dnf_context_set_solv_dir(ctx, "/tmp");
+    dnf_context_set_cache_dir(ctx, cache_dir);
+    dnf_context_set_lock_dir(ctx, cache_dir);
+
+    ret = dnf_context_setup(ctx, NULL, &error);
+    g_assert_no_error(error);
+    g_assert(ret);
+
+    /* get the repo location */
+    repo_loader = dnf_repo_loader_new(ctx);
+    repo = dnf_repo_loader_get_repo_by_id(repo_loader, "fedora", &error);
+    repo_location = dnf_repo_get_location(repo);
+
+    /* Create test files for different flags */
+    g_autofree gchar* package_directory = g_build_filename(repo_location, "packages", NULL);
+    file_result = g_mkdir_with_parents(package_directory, 0777);
+    g_assert(file_result == 0);
+
+    /* File for Cleaning Metadata */
+    g_autofree gchar* repo_data_folder = g_build_filename(repo_location, "repodata", NULL);
+    file_result = g_mkdir_with_parents(repo_data_folder, 0777);
+    g_assert(file_result == 0);
+
+    g_autofree gchar* xml_string = g_build_filename(repo_location, "metalink.xml", NULL);
+    g_fopen(xml_string, "w");
+
+    /* File for Cleaning Expired Cache */
+    g_autofree gchar* expire_cache_file = g_build_filename(repo_location, "repomd.xml", NULL);
+    g_fopen(expire_cache_file, "w");
+
+    /* File that is not for any flag case, used for testing functionality */
+    g_autofree gchar* non_matching_file = g_build_filename(repo_location, "nomatch.xxx", NULL);
+    g_fopen(non_matching_file, "w");
+
+    /* Then we do the cleaning with dnf_clean_cache, to demonstate it works */
+    DnfContextCleanFlags flags = DNF_CONTEXT_CLEAN_EXPIRE_CACHE;
+    flags |= DNF_CONTEXT_CLEAN_PACKAGES;
+    flags |= DNF_CONTEXT_CLEAN_METADATA;
+
+    ret = dnf_context_clean_cache(ctx, flags, &error);
+    g_assert(ret);
+
+    /* Verify the functionality of the function */
+    g_assert(!g_file_test(package_directory, G_FILE_TEST_EXISTS));
+    g_assert(!g_file_test(repo_data_folder, G_FILE_TEST_EXISTS));
+    g_assert(!g_file_test(xml_string, G_FILE_TEST_EXISTS));
+    g_assert(!g_file_test(expire_cache_file, G_FILE_TEST_EXISTS));
+    g_assert(g_file_test(non_matching_file, G_FILE_TEST_EXISTS));
+
+    /* At this stage we clean up the files that we created for testing */
+    dnf_remove_recursive(cache_dir, &error);
+    g_assert_no_error(error);
+}
+
 int
 main(int argc, char **argv)
 {
@@ -1087,7 +1199,9 @@ main(int argc, char **argv)
     g_test_add_func("/libdnf/repo_loader{gpg-no-asc}", dnf_repo_loader_gpg_no_asc_func);
     g_test_add_func("/libdnf/repo_loader", dnf_repo_loader_func);
     g_test_add_func("/libdnf/repo_loader{gpg-no-pubkey}", dnf_repo_loader_gpg_no_pubkey_func);
+    g_test_add_func("/libdnf/repo_loader{cache-dir-check}", dnf_repo_loader_cache_dir_check_func);
     g_test_add_func("/libdnf/context", dnf_context_func);
+    g_test_add_func("/libdnf/context{cache-clean-check}", dnf_context_cache_clean_check_func);
     g_test_add_func("/libdnf/lock", dnf_lock_func);
     g_test_add_func("/libdnf/lock[threads]", dnf_lock_threads_func);
     g_test_add_func("/libdnf/repo", ch_test_repo_func);
-- 
2.13.5

